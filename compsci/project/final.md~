# Computer Science Project
*By Nathan Windisch*

<div style="page-break-after: always;"></div>

## Introduction
### Scope
The issue is that there are not many choose-your-adventure video games on the market right now. My client is Oliver Eastgreen Cox and he has requested that I work with him to develop an application which will enable the user to play through predetermined stories, along with an audiobook being played alongside, for those with headphones who prefer listening to reading. The proposed final product, which I shall not be developing in this project but will be worked on later if further expansion is required, will have multiple free stories for the user to choose from, all with different themes and lengths in order to satisfy everyone's fictional tastes, from Science Fiction to Fantasy to Horror. All stories are intended to have multiple endings, but only a few of them may be able to be completed for this demonstration. Expansion packs could be made later down the line, to generate more profit. These expansion packs could be more stories categorised under different genres, changes to the colour scheme of the user interface or general soft currency which could be used to purchase these features or more that we add in the future. Another idea that has been toyed with is the ability for players to gain achievements while playing which, in turn will give them the soft currency for free, meaning that users can gain access to the paid content without spending any money at all, it will just be significantly harder as they will not earn as much as those that pay. As the game is single player, balance is not an issue at all due to the fact that nothing that a player does will have any significance to any other player at all. A player can cheat through the entire game and it will have no consequence to the rest of the playerbase.

To recap, the project will have the following features:

* A basic story with two or three different outcomes
* Items that are required to perform various actions within the story
* A menu which allows the user to select stories that they have selected
* A UI which is easy to use
* An options page
* A credits page

This is the full scope of the project that I shall be undertaking.

<div style="page-break-after: always;"></div>

### Boundaries
The general planned boundaries for my project, that being the inputs and outputs of the program, are as follows:
**Inputs**
* Users can create their games from a template.
* Users can save their games.
* Users can access their game later via the saved files.
* Users can perform different actions to change how the story develops.
* Users can change the options.
* Users can view the credits.
*Please note that all of these are input actions that the user can perform.*

**Outputs** 
* Program will generate a new game from a template when the user creates a game.
* Program will write their game to a file using XML as a configuration service.
* Program will read their XML save file when loading a game.
* Program will go to different parts of the story based on what actions the user performs.
* Program will update the configuration file and reload it when options changes are saved.
* Program will access and display the credits page on demand.

<div style="page-break-after: always;"></div>

### Convincing The Client
When discussing with the client for the first time we had a talk about what we wanted to create. He wanted an Android and possible an iOS application, but I explained to him that the development of two applications was too tricky. He listed the things that he wanted from the product, which I mentioned beforehand. After noting down what he wanted from me, I set to work on creating my very first Android application. After vigorous testing, I decided that it would be easier if I made a C# console variant of the game, and then ported it over to Android (and therefore Java, which is every similar language) later, once it was finished. He accepted my decision after I explained that it wouldn't take too long to convert over to Android. I had successfully convinced the client.

<div style="page-break-after: always;"></div>

### Complexity
The complexity of the project is that I shall start to work with C# to create a Console Application, then I shall port it over to Android during my second round of development. I shall attempt to add in XML, configuration, multiple classes, functions and I may look at implementing PHP and HTML in order to generate a leaderboard that users can view when not on the game, so that they can view it when not at their computers.

<div style="page-break-after: always;"></div>

## Analysis
### Outline
I have decided to approach the project by listing all the features that the client needs to have completed for a base product, what could be added to the project within the timescale and what may be added if there was a larger timespan on which to develop this program to it's full potential, if there were more time and resources available to me and my client. Some of the tasks that the client would like me to complete are:

* UI configuration
* Viewing stories grouped by genre
* Viewing stories grouped by last read
* Viewing stories grouped by user rating

The following are some tasks which would be possible if a second round of development were to be initiated, or if a longer timespan with more resources were to be used instead:

* Audio playing along with the user reader reading the story
* Access to a store page where users can purchase expansion packs and other downloadable content
* Ability to unlock and view achievements
* Ability to sign up to a web service in order to save and load progress, along with achievements and configuration profiles
* Ability to view leaderboards to see who has completed stories in the shortest amounts of time, with the most gear unlocked, who gained the most achievements and more

<div style="page-break-after: always;"></div>

### Use Case Diagram
The following is a UML 2.0 diagram that I have created to show how the proposed system will work.

<img src="resources/images/umlusecase.png" style="width=100%"></img>

As you can see, the Player has a few different options that they can choose from, such as:

* Creating the game
* Loading previously saved games
* Playing the game, which both creating and loading the game inherently extends their functionality towards
* Changing options
* Viewing the credits menu

Once they create the game, the game is instantly written to disc, meaning that it is persistent. When the user enters the game, they can view a menu which gives them two options:

* Saving the game
* Exiting the game

It is important to note that if you wish to quit and save your progress you will need to save then quit, or the game will just exit without writing your progress to the configuration files.

<div style="page-break-after: always;"></div>

### IOPS Chart
When working with my Use Case UML diagram, I discovered that there were a few IOPS procedures that needed to be looked at before I could continue. For reference, IOPS stands for `Input, Output, Processing and Storage`.

The first IOPS issue that I came across was the fact that I was not fully sure how I would allow the user to generate the default game files so that the user can create the game for the first time. I developed the following chart to make it clearer for myself when I got round to developing the actual program.

<img src="resources/images/iops1.png" style="width=100%"></img>

This is an IOPS chart that shows how a game is created. It contains redundancies to allow the user to enter the Load Game screen but still create a fresh game save if they have none currently.

The second IOPS issue that I came across is that I do not have a visual representation as to how the Change Options and Credits Menu functions will work. The following is a quick IOPS chart as to how the Change Options menu shall function:

<img src="resources/images/iops2.png" style="width=100%"></img>

The following IOPS chart is how the Credits menu will function:

<img src="resources/images/iops3.png" style="width=100%"></img>

<div style="page-break-after: always;"></div>

### SMART Objectives
After identifying my Use Case issues via IOPS, I decided to create a SMART Objectives table to list all the sub issues that I have and if they fall under the SMART categories or not. SMART stands for `Specfic`, `Measureable`, `Achieveable`, `Realistic` and `Time Bound`.

|Use Case|Objective|S|M|A|R|T|
|-|
|UC1|Checking if user is in the main menu|Y|Y|Y|Y|Y|
|UC1|Checking if user clicks "create game"|Y|Y|Y|Y|Y|
|UC1|Checking if user has a game already|Y|Y|Y|Y|Y|
|UC1|If the user has a game already, go to the Load Game screen|Y|Y|Y|Y|Y|
|UC1|If the user doesn't have a game already, go to the Create Game screen|Y|Y|Y|Y|Y|
|UC1|Checking if user clicks "load game"|Y|Y|Y|Y|Y|
|UC1|Checking if user has a game already|Y|Y|Y|Y|Y|
|UC1|If the user has a game already, go to the Load Game screen|Y|Y|Y|Y|Y|
|UC1|If the user doesn't have a game already, go to the Create Game screen|Y|Y|Y|Y|Y|
|UC2|Check if user is in the main menu|Y|Y|Y|Y|Y|
|UC2|Check if user is clicks "Change Options"|Y|Y|Y|Y|Y|
|UC2|Go to the "Change Options" menu|Y|Y|Y|Y|Y|
|UC3|Check if user is in the main menu|Y|Y|Y|Y|Y|
|UC3|Check if user is clicks "Credits"|Y|Y|Y|Y|Y|
|UC3|Go to the "Credits" menu|Y|Y|Y|Y|Y|

These are all of my SMART objectives for my three issues that I found with my Use Case Diagrams and IOPS Charts.

<div style="page-break-after: always;"></div>

### Interview
After generating all of this data I met up with my client for my first interview. The following is a rundown of what was discussed. The prefix `(O)` is for things that my client, Oliver Cox said, and the prefix `(N)` is for things that I said.

(O): So I asked you to test if the design for the system that I sent you would work. What were your findings?

(N): After lots of testing, I found that all of the things that I drew up in this Use Case Diagram would work in theory, but I had to expand each point so that I knew what to do.

*I then showed him the Use Case Diagram, which was the initial design, and the IOPS chart, which was the follow up points.*

(O): These are all very good, was there anything else that you found out during your analysis?

(N): Yes, there was. After working on my IOPS chart, I decided to create a list of SMART objectives to see if the Use Cases were Specific, Measurable, Achievable, Realistic and Time Bound.

(O): Cool, what were your findings?

(N): As you can see... *I showed him the SMART Objectives table.* All of the points within the Use Case Diagram are all Specific, Measurable, Achievable, Realistic and Time Bound.

(O): Very good, it seems as if you have been making progress. Let's have another meeting when you have more to show me.

### Feedback
I didn't get as much feedback as I would have liked from my interview with my client. I would have preferred more clearly defined tasks set up during the interview. Sadly the tasks that Oliver requested of me were more general and less specific. Luckily, I was able to relay what I had done to my client, so that he was kept on top of what I have been doing. 

<div style="page-break-after: always;"></div>

## Design
### Testing Strategy
My testing strategy can be seen below and I shall test all of the routes that my current game mock up can do and as there are a total of 4 decisions with two independent choices, I shall be using four bit binary to make a plan, where 0 is the first decision and 1 is the second. I shall then perform all these tests one after the other, and see which do not work.

Another part of my testing strategy will be testing the options menu, and if different options work with one another. The final part of the strategy will be testing if I can edit keybinds from the options menu.

<div style="page-break-after: always;"></div>

### Test Plan
The following are my test cases. Please note that the numbers under **Play Game** are due to the fact that I have a total of four tests currently set up, and each one can be dependent on any other. This means that there is a total of 16 possible tests, and I performed them all. The **Options** subsection is when I tested a quick mock up of the application, and the results can be seen in the table below.

|Test #|Test Description|Test Date|Bugs Detected?|Bugs Fixed?|New Bugs Created?|
|-|
|N/A|**Play Game**|N/A|N/A|N/A|N/A|
|01|0000|22-Jun-16|10:01|N|N/A|
|02|0001|22-Jun-16|10:03|N|N/A|
|03|0010|22-Jun-16|10:05|N|N/A|
|04|0011|22-Jun-16|10:07|N|N/A|
|05|0100|22-Jun-16|10:09|N|N/A|
|06|0101|22-Jun-16|10:11|N|N/A|
|07|0110|22-Jun-16|10:13|N|N/A|
|08|0111|22-Jun-16|10:15|N|N/A|
|09|1000|22-Jun-16|10:17|N|N/A|
|10|1001|22-Jun-16|10:19|N|N/A|
|11|1010|22-Jun-16|10:21|N|N/A|
|12|1011|22-Jun-16|10:23|N|N/A|
|13|1100|22-Jun-16|10:25|Y|Y|
|14|1101|22-Jun-16|10:27|Y|Y|
|15|1110|22-Jun-16|10:29|Y|Y|
|16|1111|22-Jun-16|10:31|Y|Y|
|N/A|**Options**|N/A|N/A|N/A|N/A|
|17|fastType enabled|22-Jun-16|10:42|N|N/A|
|19|instaType enabled|22-Jun-16|10:44|N|N/A|
|18|fastType and instaType enabled|22-Jun-16|10:46|Y|Y|
|N/A|**Edit Options**|N/A|N/A|N/A|N/A|
|20|Edit key for skip|22-Jun-16|10:53|N|N/A|
|21|Edit key for option 1|22-Jun-16|10:53|N|N/A|
|22|Edit key for option 2|22-Jun-16|10:53|N|N/A|

<div style="page-break-after: always;"></div>

### Entity Relationship Diagram
There are not many parts of my program that will require an Entity Relationship Diagram, but a part that will require it is the game saving part of my code. The following is my Entity Relationship diagram for that segment:

<img src="resources/images/er.png" style="width=100%"></img>

<div style="page-break-after: always;"></div>

### Human Computer Interaction
Human Computer Interaction is the way that Humans interacts with computer systems and programs. Human Computer Interaction is highly important as without it, users would not be able to use the software very well, if at all. Human Computer Interaction can be made possible via making easy to use instructions and documentation, meaning that users can use the software without having to go through the source code and understanding what was actually programmed. A successful point of Human Computer Interaction is a well built interface that looks like it was designed by a human rather than a computer, meaning that people will be able to use it easier.

<div style="page-break-after: always;"></div>

### Flow Chart
I have decided to make a flow chart for each Use Case that I have developed in previous segments. The first Use Case, UC1, can be seen developed into a flow chart below.

<img src="resources/images/fc1.png" style="width=100%"></img>

The following is the flow chart for UC2.

<img src="resources/images/fc2.png" style="width=100%"></img>

The following is the flow chart for UC3.

<img src="resources/images/fc3.png" style="width=100%"></img>

<div style="page-break-after: always;"></div>

### Class Diagram
`uml 2.0`
`object, module, flow`

<div style="page-break-after: always;"></div>

## Implementation
`C#, JS, SQL, PHP`
`src, annotations`

<div style="page-break-after: always;"></div>

## Testing
`evidence table, with pass/fail`
`iteration tests and fixes`

<div style="page-break-after: always;"></div>

## Evaluation
### User Acceptance Tests
User Acceptance Tests are a highly important part of the Evaluation process. User Acceptance Tests are tests which involve asking the user questions about the system and seeing if the user finds the system well built, easy to use and enjoyable to use. Sadly I had no users available to test, but I did have my client who could help me test the program. He said that the features were good and well implemented but it felt too basic for a final product. I agree with this statement, and I shall work on this the next time I work on developing new features for the program. I reminded him that this was just a prototype and that the final version would be greatly improved.

### Interview Feedback
My interview feedback can be considered similar to the User Acceptance Tests, as they were conducted by the same person. This means that all feedback given to me via the user should also be considered part of the feedback from the interview that we had, but with some more additional points:

* He would prefer it if the features that we discussed at the start of the project would be implemented, such as leaderboards, achievements and downloadable content. 
* He would also prefer it if the product was written for Android applications, which is something I will do in my second round of development later on.
* He liked the simplistic UI style with the old-school character by character typing system, as he felt it made the game nostalgic and self-aware of the games that it was built on.

<div style="page-break-after: always;"></div>

### Future Extensions:
`cost, impact, etc`
One future extension that I can add to the program is the ability for users to log into a server, in order to save your progress. Along with this feature, it means that leaderboards and profiles can be generated off that data. It also entails that users will be able to access their data across different devices. An impact of this is that it may cost lots of money to host these servers, as they will require lots of data due to the sending and receiving user's data, which could range from mere bytes to megabytes, depending on how much of the game they have completed, the amount of books they have open and the amount of achievements they have completed, unlocked or in progress. All of this data will also take up space on the server, possibly meaning that multiple hard disk drives will be required if the game's user base gets very large very fast. Hopefully this will mean that, while it may cost a lot of money to keep the game running, we will gain more money in profit, from the users that are purchasing in game products.

Another future implication is that the game will need to be updated regularly. This means that I will need to implement an update system that does not get blocked by firewalls and cannot get compromised, meaning that the game cannot get hacked and malicious software cannot get installed.
